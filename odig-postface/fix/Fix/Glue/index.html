<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Glue (fix.Fix.Glue)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">fix</a> &#x00BB; <a href="../index.html">Fix</a> &#x00BB; Glue</nav><header class="odoc-preamble"><h1>Module <code><span>Fix.Glue</span></code></h1><p><code>Glue</code> contains glue code that helps build various implementations of association maps.</p></header><div class="odoc-content"><p>Some common types, packaged as modules of signature <code>TYPE</code>.</p><div class="odoc-spec"><div class="spec module" id="module-CHAR" class="anchored"><a href="#module-CHAR" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="CHAR/index.html">CHAR</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-INT" class="anchored"><a href="#module-INT" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="INT/index.html">INT</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-STRING" class="anchored"><a href="#module-STRING" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="STRING/index.html">STRING</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>An arbitrary type can be equipped with an ordering function, just by using OCaml's built-in generic comparison function.</p><div class="odoc-spec"><div class="spec module" id="module-TrivialOrderedType" class="anchored"><a href="#module-TrivialOrderedType" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="TrivialOrderedType/index.html">TrivialOrderedType</a></span><span> (<a href="TrivialOrderedType/argument-1-T/index.html">T</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <a href="../../../ocaml/Stdlib/Map/module-type-OrderedType/index.html">Map.OrderedType</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../ocaml/Stdlib/Map/module-type-OrderedType/index.html#type-t">t</a> = <a href="TrivialOrderedType/argument-1-T/index.html#type-t">T.t</a></span></span></code></div></div><p>An arbitrary type can be equipped with equality and hash functions, just by using OCaml's built-in generic equality and hash functions.</p><div class="odoc-spec"><div class="spec module" id="module-TrivialHashedType" class="anchored"><a href="#module-TrivialHashedType" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="TrivialHashedType/index.html">TrivialHashedType</a></span><span> (<a href="TrivialHashedType/argument-1-T/index.html">T</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <a href="../../../ocaml/Stdlib/Hashtbl/module-type-HashedType/index.html">Hashtbl.HashedType</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../ocaml/Stdlib/Hashtbl/module-type-HashedType/index.html#type-t">t</a> = <a href="TrivialHashedType/argument-1-T/index.html#type-t">T.t</a></span></span></code></div></div><p>If there is an injection of <code>t</code> into <code>u</code>, then an ordering on <code>u</code> gives rise to an ordering on <code>t</code>.</p><div class="odoc-spec"><div class="spec module" id="module-InjectOrderedType" class="anchored"><a href="#module-InjectOrderedType" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="InjectOrderedType/index.html">InjectOrderedType</a></span><span> (<a href="InjectOrderedType/argument-1-U/index.html">U</a> : <a href="../../../ocaml/Stdlib/Map/module-type-OrderedType/index.html">Map.OrderedType</a>) (<a href="InjectOrderedType/argument-2-I/index.html">I</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <a href="../../../ocaml/Stdlib/Map/module-type-OrderedType/index.html">Map.OrderedType</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../ocaml/Stdlib/Map/module-type-OrderedType/index.html#type-t">t</a> = <a href="InjectOrderedType/argument-2-I/index.html#type-t">I.t</a></span></span></code></div></div><p>If there is an injection of <code>t</code> into <code>u</code>, then a hashed-type structure on <code>u</code> can be transported to <code>t</code>.</p><div class="odoc-spec"><div class="spec module" id="module-InjectHashedType" class="anchored"><a href="#module-InjectHashedType" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="InjectHashedType/index.html">InjectHashedType</a></span><span> (<a href="InjectHashedType/argument-1-U/index.html">U</a> : <a href="../../../ocaml/Stdlib/Hashtbl/module-type-HashedType/index.html">Hashtbl.HashedType</a>) (<a href="InjectHashedType/argument-2-I/index.html">I</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <a href="../../../ocaml/Stdlib/Hashtbl/module-type-HashedType/index.html">Hashtbl.HashedType</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../ocaml/Stdlib/Hashtbl/module-type-HashedType/index.html#type-t">t</a> = <a href="InjectHashedType/argument-2-I/index.html#type-t">I.t</a></span></span></code></div></div><p>If there is an injection of <code>t</code> into <code>u</code>, then an implementation of minimal imperative maps for the type <code>u</code> can be transported to the type <code>t</code>.</p><div class="odoc-spec"><div class="spec module" id="module-InjectMinimalImperativeMaps" class="anchored"><a href="#module-InjectMinimalImperativeMaps" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="InjectMinimalImperativeMaps/index.html">InjectMinimalImperativeMaps</a></span><span> (<a href="InjectMinimalImperativeMaps/argument-1-M/index.html">M</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) (<a href="InjectMinimalImperativeMaps/argument-2-I/index.html">I</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>If there is an injection of <code>t</code> into <code>u</code>, and if the inverse mapping can be effectively computed, then an implementation of imperative maps for the type <code>u</code> can be transported to the type <code>t</code>.</p><div class="odoc-spec"><div class="spec module" id="module-InjectImperativeMaps" class="anchored"><a href="#module-InjectImperativeMaps" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="InjectImperativeMaps/index.html">InjectImperativeMaps</a></span><span> (<a href="InjectImperativeMaps/argument-1-M/index.html">M</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) (<a href="InjectImperativeMaps/argument-2-I/index.html">I</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) (<a href="InjectImperativeMaps/argument-3-J/index.html">J</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>Implementations of various map signatures.</p><p>An implementation of persistent maps can be made to satisfy the interface of imperative maps. An imperative map is represented as a persistent map, wrapped within a reference cell.</p><div class="odoc-spec"><div class="spec module" id="module-PersistentMapsToImperativeMaps" class="anchored"><a href="#module-PersistentMapsToImperativeMaps" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="PersistentMapsToImperativeMaps/index.html">PersistentMapsToImperativeMaps</a></span><span> (<a href="PersistentMapsToImperativeMaps/argument-1-M/index.html">M</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>An implementation of imperative maps as arrays is possible if keys are consecutive integers.</p><div class="odoc-spec"><div class="spec module" id="module-ArraysAsImperativeMaps" class="anchored"><a href="#module-ArraysAsImperativeMaps" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="ArraysAsImperativeMaps/index.html">ArraysAsImperativeMaps</a></span><span> (<a href="ArraysAsImperativeMaps/argument-1-K/index.html">K</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>An implementation of imperative maps as a hash table.</p><div class="odoc-spec"><div class="spec module" id="module-HashTablesAsImperativeMaps" class="anchored"><a href="#module-HashTablesAsImperativeMaps" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="HashTablesAsImperativeMaps/index.html">HashTablesAsImperativeMaps</a></span><span> (<a href="HashTablesAsImperativeMaps/argument-1-H/index.html">H</a> : <a href="../../../ocaml/Stdlib/Hashtbl/module-type-HashedType/index.html">Hashtbl.HashedType</a>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>An implementation of imperative maps as a weak hash table. Use with caution: this table can forget some of its entries, and can therefore be unsuitable for use in some applications.</p><div class="odoc-spec"><div class="spec module" id="module-WeakHashTablesAsImperativeMaps" class="anchored"><a href="#module-WeakHashTablesAsImperativeMaps" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="WeakHashTablesAsImperativeMaps/index.html">WeakHashTablesAsImperativeMaps</a></span><span> (<a href="WeakHashTablesAsImperativeMaps/argument-1-H/index.html">H</a> : <a href="../../../ocaml/Stdlib/Hashtbl/module-type-HashedType/index.html">Hashtbl.HashedType</a>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p><code>MinimalSemiLattice</code> converts a semi-lattice to a minimal semi-lattice; that is, it implements <code>leq_join</code> in terms of separate <code>leq</code> and <code>join</code> operations.</p><div class="odoc-spec"><div class="spec module" id="module-MinimalSemiLattice" class="anchored"><a href="#module-MinimalSemiLattice" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="MinimalSemiLattice/index.html">MinimalSemiLattice</a></span><span> (<a href="MinimalSemiLattice/argument-1-P/index.html">P</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>