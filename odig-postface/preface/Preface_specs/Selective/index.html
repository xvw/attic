<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Selective (preface.Preface_specs.Selective)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">preface</a> &#x00BB; <a href="../index.html">Preface_specs</a> &#x00BB; Selective</nav><header class="odoc-preamble"><h1>Module <code><span>Preface_specs.Selective</span></code></h1><p>A <code>Selective</code> (applicative functor) allows to declare effects statically and select which execute dynamically. It is an algebraic structure between <a href="../Applicative/index.html"><code>Applicative</code></a> and <a href="../Monad/index.html"><code>Monad</code></a>. A <code>Selective</code> is also an <a href="../Applicative/index.html"><code>Applicative</code></a>.</p></header><nav class="odoc-toc"><ul><li><a href="#laws">Laws</a><ul><li><a href="#laws-for-rigid-selectives">Laws for Rigid Selectives</a></li></ul></li><li><a href="#minimal-definition">Minimal definition</a></li><li><a href="#structure-anatomy">Structure anatomy</a></li><li><a href="#complete-api">Complete API</a></li><li><a href="#additional-references">Additional references</a></li></ul></nav><div class="odoc-content"><h3 id="laws"><a href="#laws" class="anchor"></a>Laws</h3><p>To have a predictable behaviour, the instance of <code>Selective</code> must obey some laws.</p><ol><li><code>x &lt;*? pure id = Either.case id id &lt;$&gt; x</code></li><li><code>pure x &lt;*? (y *&gt; z) = (pure x &lt;*? y) *&gt; (pure x &lt;*? z)</code></li><li><code>x &lt;*? (y &lt;*? z) = (f &lt;$&gt; x) &lt;*? (g &lt;$&gt; y) &lt;*? (h &lt;$&gt; z)</code></li><li><code>f &lt;$&gt; select x y) = (select (Bifunctor.map_snd f &lt;$&gt; x) (((%) f) &lt;$&gt; y)</code></li><li><code>(select (Bifunctor.map_fst f &lt;$&gt; x) y) = (select x ((%&gt;) f) &lt;$&gt; y))</code></li><li><code>(select x (f &lt;$&gt; y)) = (select (Bifunctor.map_fst (flip f) &lt;$&gt; x) ((|&gt;) \
     &lt;$&gt; y))</code></li><li><code>(x &lt;*? pure y) = (Either.case y id &lt;$&gt; x)</code></li><li><code>(pure (Right x) &lt;*? y) = pure x</code></li><li><code>(pure (Left x) &lt;*? y) = ((|&gt;) x) &lt;$&gt; y</code></li></ol><h4 id="laws-for-rigid-selectives"><a href="#laws-for-rigid-selectives" class="anchor"></a>Laws for Rigid Selectives</h4><p>A <code>selective</code> is <code>Rigid</code> if <code>apply</code> can be defined in term of <code>select</code></p><ol><li><code>f &lt;*&gt; g = apply f g</code></li><li><code>(x *&gt; (y &lt;*? z)) = ((x *&gt; y) &lt;*? z)</code></li></ol><h2 id="minimal-definition"><a href="#minimal-definition" class="anchor"></a>Minimal definition</h2><div class="odoc-spec"><div class="spec module-type" id="module-type-WITH_SELECT" class="anchored"><a href="#module-type-WITH_SELECT" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-WITH_SELECT/index.html">WITH_SELECT</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Minimal definition using <code>select</code> without <a href="../Applicative/index.html"><code>Applicative</code></a> requirements.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-WITH_BRANCH" class="anchored"><a href="#module-type-WITH_BRANCH" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-WITH_BRANCH/index.html">WITH_BRANCH</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Minimal definition using <code>branch</code> without <a href="../Applicative/index.html"><code>Applicative</code></a> requirements.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-WITH_PURE_AND_SELECT" class="anchored"><a href="#module-type-WITH_PURE_AND_SELECT" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-WITH_PURE_AND_SELECT/index.html">WITH_PURE_AND_SELECT</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Standard requirement including <code>pure</code> and <code>select</code>.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-WITH_PURE_AND_BRANCH" class="anchored"><a href="#module-type-WITH_PURE_AND_BRANCH" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-WITH_PURE_AND_BRANCH/index.html">WITH_PURE_AND_BRANCH</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Standard requirement including <code>pure</code> and <code>branch</code>.</p></div></div><h2 id="structure-anatomy"><a href="#structure-anatomy" class="anchor"></a>Structure anatomy</h2><div class="odoc-spec"><div class="spec module-type" id="module-type-CORE" class="anchored"><a href="#module-type-CORE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-CORE/index.html">CORE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Basis operation.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-OPERATION" class="anchored"><a href="#module-type-OPERATION" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-OPERATION/index.html">OPERATION</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Additional operations.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-SYNTAX" class="anchored"><a href="#module-type-SYNTAX" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-SYNTAX/index.html">SYNTAX</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Syntax extensions.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-INFIX" class="anchored"><a href="#module-type-INFIX" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-INFIX/index.html">INFIX</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Infix operators.</p></div></div><h2 id="complete-api"><a href="#complete-api" class="anchor"></a>Complete API</h2><div class="odoc-spec"><div class="spec module-type" id="module-type-API" class="anchored"><a href="#module-type-API" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-API/index.html">API</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The complete interface of a <code>Selective</code>.</p></div></div><h2 id="additional-references"><a href="#additional-references" class="anchor"></a>Additional references</h2><ul><li><a href="http://hackage.haskell.org/package/selective">Haskell's documentation of a Selective Application Functor</a></li><li><a href="https://www.staff.ncl.ac.uk/andrey.mokhov/selective-functors.pdf">Selective Applicative Functors</a></li></ul></div></body></html>