<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>As_monoid (postface.Postface_examples.Ordering_examples.As_monoid)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">postface</a> &#x00BB; <a href="../../index.html">Postface_examples</a> &#x00BB; <a href="../index.html">Ordering_examples</a> &#x00BB; As_monoid</nav><header class="odoc-preamble"><h1>Module <code><span>Ordering_examples.As_monoid</span></code></h1><p>Examples of using Ordering as a <a href="../../../Postface/Ordering/Monoid/index.html"><code>Postface.Ordering.Monoid</code></a></p><p>An Ordering forms a monoid, so it has a neutral element and a combination function.</p><p>The neutral element is <code>Eq</code> so when we use <code>combine</code> or the infix operator <code>&lt;|&gt;</code>, when <code>Eq</code> is in the operation it does not influence the computation:</p><pre><code># Ordering.Monoid.combine Eq Lt ;;
- : Ordering.t = Lt</code></pre><pre><code># Ordering.Monoid.combine Gt Eq ;;
- : Ordering.t = Gt</code></pre><p>The association rules may seem a bit strange, but this is because the monoid described by Ordering is an <b>idempotent monoid</b>, which is also sometimes called a <i>find-first</i>. Yeah when the first element of the operation is not the neutral-one, it takes it a reference.</p><pre><code># Ordering.Monoid.combine Lt Gt ;;
- : Ordering.t = Lt</code></pre><pre><code># Ordering.Monoid.combine Gt Lt ;;
- : Ordering.t = Gt</code></pre><p>Knowing this, we can easily speculate on the behaviour of <code>reduce</code> (which will apply <code>combine</code> on all the ordering present in a list, taking as a starting value the neutral element, here <code>Eq</code>), the result will be always the first element which is not <code>Eq</code> (if there is on element that is not <code>Eq</code>, of course).</p><p>Here, the result will be <code>Gt</code>, easy!</p><pre><code># Ordering.Monoid.reduce [Gt; Lt; Lt; Eq; Gt] ;;
- : Ordering.t = Gt</code></pre><p>And here, the result will be <code>Lt</code>.</p><pre><code># Ordering.Monoid.reduce [Eq; Eq; Lt; Gt; Gt] ;;
- : Ordering.t = Lt</code></pre><p>If, on the other hand, we have nothing more than <code>Eq</code>, we are left with an embarrassing <code>Eq</code> at the end.</p><pre><code># Ordering.Monoid.reduce [Eq; Eq] ;;
- : Ordering.t = Eq</code></pre><p>That's all we needed to know about Ordering Monoid!</p></header><div class="odoc-content"></div></body></html>