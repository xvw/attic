<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Indexing (fix.Fix.Indexing)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">fix</a> &#x00BB; <a href="../index.html">Fix</a> &#x00BB; Indexing</nav><header class="odoc-preamble"><h1>Module <code><span>Fix.Indexing</span></code></h1><p>This module provides support for constructing finite sets at the type level and for encoding the inhabitants of these sets as runtime integers. These runtime integers are statically branded with the name of the set that they inhabit, so two inhabitants of two distinct sets cannot be inadvertently confused.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-cardinal" class="anchored"><a href="#type-cardinal" class="anchor"></a><code><span><span class="keyword">type</span> <span>'n cardinal</span></span></code></div><div class="spec-doc"><p>If <code>n</code> is a type-level name for a finite set, then a value of type <code>n cardinal</code> is a runtime integer that represents the cardinal of the set <code>n</code>.</p><p>In the following, the functor <code>Gensym</code> allows creating open-ended sets, which can grow over time. If <code>n</code> is such a set, then a value of type <code>n cardinal</code> can be thought of as the as-yet-undetermined cardinal of the set.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cardinal" class="anchored"><a href="#val-cardinal" class="anchor"></a><code><span><span class="keyword">val</span> cardinal : <span><span><span class="type-var">'n</span> <a href="#type-cardinal">cardinal</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>If <code>n</code> is the cardinal of the set <code>n</code>, then <code>cardinal n</code> returns the cardinal of this set, as a concrete integer.</p><p>In the following, the functor <code>Gensym</code> allows creating open-ended sets, which can grow over time. If <code>n</code> is such a set, then calling <code>cardinal n</code> has the side-effect of freezing this set, thereby fixing its cardinal: thereafter, calling <code>fresh</code> becomes forbidden, so no new elements can be added.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-index" class="anchored"><a href="#type-index" class="anchor"></a><code><span><span class="keyword">type</span> <span>'n index</span></span><span> = <span class="keyword">private</span> int</span></code></div><div class="spec-doc"><p>If <code>n</code> is a type-level name for a finite set, then a value <code>i</code> of type <code>n index</code> is an integer value that is guaranteed to inhabit the set <code>n</code>.</p><p>If <code>n</code> has type <code>n cardinal</code>, then <code>0 &lt;= i &lt; cardinal n</code> must hold.</p><p>The main reason why elements of a finite set are called &quot;indices&quot; is that their main purpose is to serve as indices in fixed-size vectors. See the submodule <code>Vector</code> below.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-CARDINAL" class="anchored"><a href="#module-type-CARDINAL" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-CARDINAL/index.html">CARDINAL</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A new type-level set is created by an application of the functor <a href="Const/index.html"><code>Const</code></a>, <a href="Gensym/index.html"><code>Gensym</code></a>, and <a href="Sum/index.html"><code>Sum</code></a> below. Each functor application creates a fresh type name <code>n</code>. More precisely, each functor application returns a module whose signature is <a href="module-type-CARDINAL/index.html"><code>CARDINAL</code></a>: it contains both a fresh abstract type <code>n</code> and a value <code>n</code> of type <code>n cardinal</code> that represents the cardinal of the newly-created set.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Const" class="anchored"><a href="#module-Const" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Const/index.html">Const</a></span><span> (<a href="Const/argument-1-X/index.html">X</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <a href="module-type-CARDINAL/index.html">CARDINAL</a></span></code></div><div class="spec-doc"><p><code>Const(struct let cardinal = c end)</code> creates a fresh type-level name for a set whose cardinal is <code>c</code>. <code>c</code> must be nonnegative.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-const" class="anchored"><a href="#val-const" class="anchor"></a><code><span><span class="keyword">val</span> const : <span>int <span class="arrow">&#45;&gt;</span></span> <span>(<span class="keyword">module</span> <a href="module-type-CARDINAL/index.html">CARDINAL</a>)</span></span></code></div><div class="spec-doc"><p>The function <code>const</code> is a value-level analogue of the functor <a href="Const/index.html"><code>Const</code></a>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Empty" class="anchored"><a href="#module-Empty" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Empty/index.html">Empty</a></span><span> : <a href="module-type-CARDINAL/index.html">CARDINAL</a></span></code></div><div class="spec-doc"><p><code>Empty</code> contains a type-level name for the empty set.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Gensym" class="anchored"><a href="#module-Gensym" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Gensym/index.html">Gensym</a></span><span> () : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Gensym()</code> creates an open-ended type-level set, whose cardinality is not known a priori. As long as the cardinal of the set has not been observed by invoking <code>cardinal</code>, new elements can be added to the set by invoking <code>fresh</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-either" class="anchored"><a href="#type-either" class="anchor"></a><code><span><span class="keyword">type</span> <span>('l, 'r) either</span></span><span> = </span></code><table><tr id="type-either.L" class="anchored"><td class="def variant constructor"><a href="#type-either.L" class="anchor"></a><code><span>| </span><span><span class="constructor">L</span> <span class="keyword">of</span> <span class="type-var">'l</span></span></code></td></tr><tr id="type-either.R" class="anchored"><td class="def variant constructor"><a href="#type-either.R" class="anchor"></a><code><span>| </span><span><span class="constructor">R</span> <span class="keyword">of</span> <span class="type-var">'r</span></span></code></td></tr></table></div><div class="spec-doc"><p>The type <code>('l, 'r) either</code> represents the disjoint sum of the types <code>'l</code> and <code>'r</code>. It is isomorphic to the type <code>either</code> found in <code>Stdlib.Either</code> in OCaml 4.12.0.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-SUM" class="anchored"><a href="#module-type-SUM" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-SUM/index.html">SUM</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The signature <code>SUM</code> extends <code>CARDINAL</code> with an explicit isomorphism between the set <code>n</code> and the disjoint sum <code>l + r</code>. The functions <code>inj_l</code> and <code>inj_r</code> convert an index into <code>l</code> or an index into <code>r</code> into an index into <code>n</code>. Conversely, the function <code>prj</code> converts an index into <code>r</code> into either an index into <code>l</code> or an index into <code>r</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Sum" class="anchored"><a href="#module-Sum" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Sum/index.html">Sum</a></span><span> (<a href="Sum/argument-1-L/index.html">L</a> : <a href="module-type-CARDINAL/index.html">CARDINAL</a>) (<a href="Sum/argument-2-R/index.html">R</a> : <a href="module-type-CARDINAL/index.html">CARDINAL</a>) : <a href="module-type-SUM/index.html">SUM</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-SUM/index.html#type-l">l</a> := <a href="Sum/argument-1-L/index.html#type-n">L.n</a></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="module-type-SUM/index.html#type-r">r</a> := <a href="Sum/argument-2-R/index.html#type-n">R.n</a></span></span></code></div><div class="spec-doc"><p><code>Sum(L)(R)</code> creates a new type-level set, which is the disjoint sums of the sets <code>L</code> and <code>R</code>. The functor application <code>Sum(L)(R)</code> involves a call to <code>cardinal L.n</code>, thereby fixing the cardinal of the set <code>L</code>, if it was an open-ended set. The cardinal of the set <code>R</code> is not fixed: if <code>R</code> is an open-ended set, then the new set is open-ended as well, and it is still permitted to add new elements to <code>R</code> by calling <code>R.fresh()</code>. Fixing the cardinal of the new set fixes the cardinal of <code>R</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sum" class="anchored"><a href="#val-sum" class="anchor"></a><code><span><span class="keyword">val</span> sum : <span><span><span class="type-var">'l</span> <a href="#type-cardinal">cardinal</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'r</span> <a href="#type-cardinal">cardinal</a></span> <span class="arrow">&#45;&gt;</span></span> <span>(<span class="keyword">module</span> <a href="module-type-SUM/index.html">SUM</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-SUM/index.html#type-l">l</a> = <span class="type-var">'l</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-SUM/index.html#type-r">r</a> = <span class="type-var">'r</span>)</span></span></code></div><div class="spec-doc"><p>The function <code>sum</code> is a value-level analogue of the functor <a href="Sum/index.html"><code>Sum</code></a>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Index" class="anchored"><a href="#module-Index" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Index/index.html">Index</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The submodule <code>Index</code> allows safely manipulating indices into a finite set.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-vector" class="anchored"><a href="#type-vector" class="anchor"></a><code><span><span class="keyword">type</span> <span>('n, 'a) vector</span></span><span> = <span class="keyword">private</span> <span><span class="type-var">'a</span> array</span></span></code></div><div class="spec-doc"><p>A vector of type <code>(n, a) vector</code> is a (fixed-size) array whose indices lie in the type-level set <code>n</code> and whose elements have type <code>a</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Vector" class="anchored"><a href="#module-Vector" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Vector/index.html">Vector</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The submodule <code>Vector</code> allows safely manipulating indices into a vector.</p></div></div></div></body></html>