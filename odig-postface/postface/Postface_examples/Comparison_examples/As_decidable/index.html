<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>As_decidable (postface.Postface_examples.Comparison_examples.As_decidable)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">postface</a> &#x00BB; <a href="../../index.html">Postface_examples</a> &#x00BB; <a href="../index.html">Comparison_examples</a> &#x00BB; As_decidable</nav><header class="odoc-preamble"><h1>Module <code><span>Comparison_examples.As_decidable</span></code></h1><p>Examples of using Comparison as a <a href="../../../Postface/Comparison/Decidable/index.html"><code>Postface.Comparison.Decidable</code></a></p><p>Although we have seen how to compose comparison functions to act on products using <a href="../As_divisible/index.html">Divisible</a>, we have also seen that, due to the idempotent nature of the ordering monoid, the result can be surprising and that the order of observation of the product fields varies the result.</p><p>As for <a href="../../Predicate_examples/As_decidable/index.html">predicates</a> and for <a href="../../Equivalence_examples/As_decidable/index.html">equivalences</a> can construct comparisons that act on sums, but for the same reasons as in <code>Divisible</code>, the result of these comparisons can be surprising.</p><p>Let's look at this strangeness with our good old type <code>int_or_float</code> and its projection function into an <code>either</code>:</p><pre><code># type int_or_float = Int of int | Float of float ;;
type int_or_float = Int of int | Float of float</code></pre><p>As before, we need to project our value into a <code>either</code>. Let's use our <code>to_either</code> function again:</p><pre><code># let to_either = function Int x -&gt; Either.left x | Float x -&gt; Either.right x ;;
val to_either : int_or_float -&gt; (int, float) Either/2.t = &lt;fun&gt;</code></pre><p>Now we can write a comparison that will act on values of this type, broadly in the same way as for predicates or equivalences:</p><pre><code># let cmp_int = from_stdlib Stdlib.Int.compare ;;
val cmp_int : int Comparison.t = &lt;comparison&gt;
# let cmp_float = from_stdlib Stdlib.Float.compare ;;
val cmp_float : float Comparison.t = &lt;comparison&gt;
# let cmp = to_either &gt;$&lt; Stdlib.(cmp_int&gt;|&lt; cmp_float) ;;
val cmp : int_or_float Comparison.t = &lt;comparison&gt;</code></pre><p>So far so good, let's try our new comparison function:</p><pre><code># cmp (Int 10) (Int 10) ;;
- : Ordering.t = Eq
# cmp (Float 5.0) (Float 5.0) ;;
- : Ordering.t = Eq
# cmp (Int 1) (Int 2) ;;
- : Ordering.t = Lt</code></pre><p>Great, everything seems to work! Let's quickly test something else:</p><pre><code># cmp (Float 3.0) (Int 12) ;;
- : Ordering.t = Gt</code></pre><p>For exactly the same reasons that the order of the fields mattered in the case of Divisible, here a <code>Left</code> value will always be smaller than a <code>Right</code> value. It is partly for these reasons that it is better to construct a specific comparison function than to use <code>Decidable</code>, in this way for example:</p><pre><code># let to_float = function Float x -&gt; x | Int x -&gt; Stdlib.float_of_int x ;;
val to_float : int_or_float -&gt; float = &lt;fun&gt;
# let cmp x y = cmp_float (to_float x) (to_float y) ;;
val cmp : int_or_float -&gt; int_or_float -&gt; Ordering.t = &lt;comparison&gt;</code></pre><p>Which does not impose a weighting according to the order of projection in <code>either</code>.</p></header><div class="odoc-content"></div></body></html>