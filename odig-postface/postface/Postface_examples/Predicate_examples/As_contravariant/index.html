<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>As_contravariant (postface.Postface_examples.Predicate_examples.As_contravariant)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">postface</a> &#x00BB; <a href="../../index.html">Postface_examples</a> &#x00BB; <a href="../index.html">Predicate_examples</a> &#x00BB; As_contravariant</nav><header class="odoc-preamble"><h1>Module <code><span>Predicate_examples.As_contravariant</span></code></h1><p>Examples of using Predicates as a <a href="../../../Postface/Predicate/Contravariant/index.html"><code>Postface.Predicate.Contravariant</code></a> Functor</p><p>By using <code>negate</code>, <code>and_</code> and <code>or_</code> we have seen how to compose predicates with each other, however, we were only acting on predicates of the same type. Sometimes we want to promote/lifter a predicate to act on more complex structures.</p><p>For example, consider this function which returns a predicate which checks that an integer is equal to the parameter passed to the function:</p><pre><code># let is_equal_to x = Int.equal x;;
val is_equal_to : int -&gt; int -&gt; bool = &lt;fun&gt;</code></pre><p>Let's say we want to use it to calculate the size of a list. We could manually define this function, which would return a predicate that would act on a list:</p><pre><code># let has_size s l = is_equal_to s (List.length l) ;;
val has_size : int -&gt; 'a list -&gt; bool = &lt;fun&gt;</code></pre><p>It works perfectly, however, there is a systematic way to <b>change the focus</b> (i.e., transform a predicate by allowing it to act on a given prism) using <a href="../../../Postface/Predicate/Contravariant/index.html#val-contramap">contramap</a> :</p><pre><code># let has_size s = Contravariant.contramap List.length (is_equal_to s) ;;
val has_size : int -&gt; 'a list t = &lt;fun&gt;</code></pre><p>which could be described more concisely, using the infix version of contramap as follows:</p><pre><code># open Contravariant ;;
# let has_size s = List.length &gt;$&lt; (is_equal_to s) ;;
val has_size : int -&gt; 'a list t = &lt;fun&gt;</code></pre><p>And now we can test it all. In this case, the function will return <code>false</code> because the list has size <code>4</code> and not <code>10</code>.</p><pre><code># has_size 10 [1; 2; 3; 4] ;;
- : bool = false</code></pre><p>Let's try it now with a list size of <code>4</code> and an expected size of <code>4</code>, everything should go better!</p><pre><code># has_size 4 [10; 11; 12; 13] ;;
- : bool = true</code></pre><p>To summarise, <code>contramap</code> will apply a function to the value to be checked before applying the predicate. In our example, <code>List.length</code> is the function, and we apply it to our function <code> is_equal_to 10 </code> which produces a new predicate that checks that the size of the list is <code>10</code>.</p><p>Although this may seem trivial, it allows us to generalise predicates generically and can be applied to the more complex constructions that we will look at in <code>Afterword</code>. In addition, in the same way that functors can be used as a basis for application pipelines, it is possible to construct more complex predicates, for example using <a href="../As_divisible/index.html">Divisible</a>.</p></header><div class="odoc-content"></div></body></html>