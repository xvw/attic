<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>As_decidable (postface.Postface_examples.Predicate_examples.As_decidable)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">postface</a> &#x00BB; <a href="../../index.html">Postface_examples</a> &#x00BB; <a href="../index.html">Predicate_examples</a> &#x00BB; As_decidable</nav><header class="odoc-preamble"><h1>Module <code><span>Predicate_examples.As_decidable</span></code></h1><p>Examples of using Predicates as a <a href="../../../Postface/Predicate/Decidable/index.html"><code>Postface.Predicate.Decidable</code></a></p><p>Using <a href="../As_divisible/index.html">Divisible</a>, we observed how to apply multiple predicates on multiple members of a value by transforming it into a product (a couple). <code>Decidable</code> allows you to act on <b>sums</b>, i.e. to apply a different predicate depending on the branch you are in. For example, imagine this type of data:</p><pre><code>type int_or_float = Int of int | Float of float</code></pre><p>As always, it is possible to define a direct implementation that does not use the functions of the <code>Decidable</code> module at all, for example in this way:</p><pre><code>let check_int_or_float (p_int : int t) (p_float : float t) = function
| Int x -&gt; p_int x
| Float x -&gt; p_float x</code></pre><pre><code># check_int_or_float ;;
- : int t -&gt; float t -&gt; int_or_float -&gt; bool = &lt;fun&gt;</code></pre><p>But in order to select (<b>decide</b>) which predicate to invoke in branches of sums, it is necessary, as with products, to use a generic representation of sums, and it turns out that while the type <code>'a * 'b</code> represents the most generic product (of at least two elements) possible, <code>('a, 'b) Either.t</code> represents the most generic sum (of at least two cases, with only one case, like for <code>Divisible</code>, <code>Contravariant</code> is sufficient) possible. We therefore need to provide a function capable of projecting our <code>int_or_float</code> type into an <code>either</code>.</p><pre><code>let to_either = function
| Int x -&gt; Either.left x
| Float x -&gt; Either.right x</code></pre><pre><code># to_either ;;
- : int_or_float -&gt; (int, float) Either/2.t = &lt;fun&gt;</code></pre><p>And now we can use <code>&gt;|&lt;</code>, the infix operator for <a href="../../../Postface/Predicate/Decidable/index.html#val-chosen">chosen</a> so that the correct predicate is passed to the value:</p><pre><code># let check p_int p_float = to_either &gt;$&lt; (p_int &gt;|&lt; p_float) ;;
val check : int t -&gt; float t -&gt; int_or_float t = &lt;fun&gt;</code></pre><p>The scheme follows the same form as seen in <code>Divisible</code>, i.e. : <code>projection &gt;$&lt; (p op p2 op p3)</code>. First we project our value into its generic representation with <code>&gt;$&lt;</code>, and then we string our predicates with our basic operator (<code>&gt;*&lt;</code> for <code>Divisible</code> and <code>&gt;|&lt;</code> for <code>Decidable</code>). Without further ado, let's test our function with two predicates. We would like to validate only numbers greater than 10:</p><pre><code># let p = check (fun x -&gt; x &gt; 10) (fun x -&gt; x &gt; 10.0) ;;
val p : int_or_float t = &lt;predicate&gt;
# p (Int 11) ;;
- : bool = true
# p (Float 12.0) ;;
- : bool = true
# p (Int 10) ;;
- : bool = false
# p (Float 9.999999) ;;
- : bool = false</code></pre><p>In the same way as for products, it is possible to construct types with more than two branches. For example, let's imagine this type:</p><pre><code>type more_than_2_branches = A of int | B of float | C of string  </code></pre><p>A function <code>to_either</code> of this form can be produced:</p><pre><code>let to_either = function
| A x -&gt; Either.(left (left x))
| B x -&gt; Either.(left (right x))
| C x -&gt; Either.right x</code></pre><p>For which we can provide this function <code>check</code>.</p><pre><code># let check a b c = to_either &gt;$&lt; (a &gt;|&lt; b &gt;|&lt; c) ;;
val check : int t -&gt; float t -&gt; string t -&gt; more_than_2_branches t = &lt;fun&gt;</code></pre><p>As you can see, the projection logic is broadly the same as for products.</p></header><div class="odoc-content"></div></body></html>