<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fix (fix.Fix)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">fix</a> &#x00BB; Fix</nav><header class="odoc-preamble"><h1>Module <code><span>Fix</span></code></h1></header><div class="odoc-content"><div class="odoc-include"><div class="odoc-spec"><div class="spec module-type" id="module-type-TYPE" class="anchored"><a href="#module-type-TYPE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-TYPE/index.html">TYPE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>An ordered type. A hashed type. These are standard notions.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-OrderedType" class="anchored"><a href="#module-type-OrderedType" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span>OrderedType</span><span> = <a href="../../ocaml/Stdlib/Map/module-type-OrderedType/index.html">Map.OrderedType</a></span></code></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-HashedType" class="anchored"><a href="#module-type-HashedType" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span>HashedType</span><span> = <a href="../../ocaml/Stdlib/Hashtbl/module-type-HashedType/index.html">Hashtbl.HashedType</a></span></code></div></div><p>A type whose elements can be enumerated.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-FINITE_TYPE" class="anchored"><a href="#module-type-FINITE_TYPE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-FINITE_TYPE/index.html">FINITE_TYPE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>Association maps.</p><p>Following the convention of the ocaml standard library, <code>find</code> raises the exception <code>Not_found</code> when the key is not in the domain of the map. In contrast, <code>get</code> returns an option.</p><p>Persistent maps. The empty map is a constant. Insertion creates a new map.</p><p>This is a fragment of the standard signature <code>Map.S</code>.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-PERSISTENT_MAPS" class="anchored"><a href="#module-type-PERSISTENT_MAPS" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-PERSISTENT_MAPS/index.html">PERSISTENT_MAPS</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>Imperative maps. A fresh empty map is produced by <code>create</code>. Insertion updates a map in place. <code>clear</code> empties an existing map.</p><p>The order of the arguments to <code>add</code> and <code>find</code> is consistent with the order used in <code>PERSISTENT_MAPS</code> above. Thus, it departs from the convention used in OCaml's <code>Hashtbl</code> module.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-MINIMAL_IMPERATIVE_MAPS" class="anchored"><a href="#module-type-MINIMAL_IMPERATIVE_MAPS" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-MINIMAL_IMPERATIVE_MAPS/index.html">MINIMAL_IMPERATIVE_MAPS</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-IMPERATIVE_MAPS" class="anchored"><a href="#module-type-IMPERATIVE_MAPS" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-IMPERATIVE_MAPS/index.html">IMPERATIVE_MAPS</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-ARRAY" class="anchored"><a href="#module-type-ARRAY" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-ARRAY/index.html">ARRAY</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>An instance of the signature <code>ARRAY</code> represents one mutable map. There is no type <code>'data t</code> and no <code>create</code> operation; there exists just one map. Furthermore, the type <code>value</code>, which corresponds to <code>'data</code> in the previous signatures, is fixed.</p></div></div><p>The signature <code>PROPERTY</code> is used by <code>Fix.Make</code>, the least fixed point computation algorithm.</p><p>The type <code>property</code> must form a partial order. It must be equipped with a least element <code>bottom</code> and with an equality test <code>equal</code>. (In the function call <code>equal p q</code>, it is permitted to assume that <code>p &lt;= q</code> holds.) We do not require an ordering test <code>leq</code>. We do not require a join operation <code>lub</code>. We do require the ascending chain condition: every monotone sequence must eventually stabilize.</p><p>The function <code>is_maximal</code> determines whether a property <code>p</code> is maximal with respect to the partial order. Only a conservative check is required: in any event, it is permitted for <code>is_maximal p</code> to be <code>false</code>. If <code>is_maximal p</code> is <code>true</code>, then <code>p</code> must have no strict upper bound. In particular, in the case where properties form a lattice, this means that <code>p</code> must be the top element.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-PROPERTY" class="anchored"><a href="#module-type-PROPERTY" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-PROPERTY/index.html">PROPERTY</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>The signature <code>SEMI_LATTICE</code> offers separate <code>leq</code> and <code>join</code> functions. The functor <code>Glue.MinimalSemiLattice</code> can be used, if necessary, to convert this signature to <code>MINIMAL_SEMI_LATTICE</code>.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-SEMI_LATTICE" class="anchored"><a href="#module-type-SEMI_LATTICE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-SEMI_LATTICE/index.html">SEMI_LATTICE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>The signature <code>MINIMAL_SEMI_LATTICE</code> is used by <code>Fix.DataFlow</code>.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-MINIMAL_SEMI_LATTICE" class="anchored"><a href="#module-type-MINIMAL_SEMI_LATTICE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-MINIMAL_SEMI_LATTICE/index.html">MINIMAL_SEMI_LATTICE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>The type of a fixed point combinator that constructs a value of type <code>'a</code>.</p><div class="odoc-spec"><div class="spec type" id="type-fix" class="anchored"><a href="#type-fix" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a fix</span></span><span> = <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><p>Memoizers -- higher-order functions that construct memoizing functions.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-MEMOIZER" class="anchored"><a href="#module-type-MEMOIZER" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-MEMOIZER/index.html">MEMOIZER</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>Tabulators: higher-order functions that construct tabulated functions.</p><p>Like memoization, tabulation guarantees that, for every key <code>x</code>, the image <code>f x</code> is computed at most once. Unlike memoization, where this computation takes place on demand, in the case of tabulation, the computation of every <code>f x</code> takes place immediately, when <code>tabulate</code> is invoked. The graph of the function <code>f</code>, a table, is constructed and held in memory.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-TABULATOR" class="anchored"><a href="#module-type-TABULATOR" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-TABULATOR/index.html">TABULATOR</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>Solvers: higher-order functions that compute the least solution of a monotone system of equations.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-SOLVER" class="anchored"><a href="#module-type-SOLVER" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-SOLVER/index.html">SOLVER</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>The signature <code>SOLUTION</code> is used to describe the result of <code>Fix.DataFlow</code>.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-SOLUTION" class="anchored"><a href="#module-type-SOLUTION" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-SOLUTION/index.html">SOLUTION</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>Directed, rooted graphs.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-GRAPH" class="anchored"><a href="#module-type-GRAPH" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-GRAPH/index.html">GRAPH</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>The signature <code>DATA_FLOW_GRAPH</code> is used to describe a data flow analysis problem. It is used to describe the input to <code>Fix.DataFlow</code>.</p><p>The function <code>foreach_root</code> describes the root nodes of the data flow graph as well as the properties associated with them. <code>foreach_call contribute</code> is expected to call <code>contribute x p</code> to indicate that <code>x</code> is a root and that <code>p</code> is a lower bound on the solution at <code>x</code>. It is permitted to call <code>contribute x _</code> several times at a root <code>x</code>.</p><p>The function <code>foreach_successor</code> describes the edges of the data flow graph as well as the manner in which a property at the source of an edge is transformed into a property at the target. The property at the target must of course be a monotonic function of the property at the source.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-DATA_FLOW_GRAPH" class="anchored"><a href="#module-type-DATA_FLOW_GRAPH" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-DATA_FLOW_GRAPH/index.html">DATA_FLOW_GRAPH</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>Numberings.</p><p>An ongoing numbering of (a subset of) a type <code>t</code> offers a function <code>encode</code> which maps a value of type <code>t</code> to a unique integer code. If applied twice to the same value, <code>encode</code> returns the same code; if applied to a value that has never been encountered, it returns a fresh code. The function <code>current</code> returns the next available code, which is also the number of values that have been encoded so far. The function <code>has_been_encoded</code> tests whether a value has been encoded already.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-ONGOING_NUMBERING" class="anchored"><a href="#module-type-ONGOING_NUMBERING" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-ONGOING_NUMBERING/index.html">ONGOING_NUMBERING</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>A numbering of (a subset of) a type <code>t</code> is a triple of an integer <code>n</code> and two functions <code>encode</code> and <code>decode</code> which represent an isomorphism between this subset of <code>t</code> and the interval <code>[0..n)</code>.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-NUMBERING" class="anchored"><a href="#module-type-NUMBERING" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-NUMBERING/index.html">NUMBERING</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>A combination of the above two signatures. According to this signature, a numbering process is organized in two phases. During the first phase, the numbering is ongoing; one can encode keys, but not decode. Applying the functor <code>Done()</code> ends the first phase. A fixed numbering then becomes available, which gives access to the total number <code>n</code> of encoded keys and to both <code>encode</code> and <code>decode</code> functions.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-TWO_PHASE_NUMBERING" class="anchored"><a href="#module-type-TWO_PHASE_NUMBERING" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-TWO_PHASE_NUMBERING/index.html">TWO_PHASE_NUMBERING</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>Injections.</p><p>An injection of <code>t</code> into <code>u</code> is an injective function of type <code>t -&gt; u</code>. Because <code>encode</code> is injective, <code>encode x</code> can be thought of as the identity of the object <code>x</code>.</p><div class="odoc-spec"><div class="spec module-type" id="module-type-INJECTION" class="anchored"><a href="#module-type-INJECTION" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-INJECTION/index.html">INJECTION</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div><div class="odoc-spec"><div class="spec module" id="module-Glue" class="anchored"><a href="#module-Glue" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Glue/index.html">Glue</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Glue</code> contains glue code that helps build various implementations of association maps.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Memoize" class="anchored"><a href="#module-Memoize" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Memoize/index.html">Memoize</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Memoize</code> offers a number of combinators that help construct possibly recursive memoizing functions, that is, functions that lazily record their input/output graph, so as to avoid repeated computation.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Numbering" class="anchored"><a href="#module-Numbering" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Numbering/index.html">Numbering</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Numbering</code> offers a facility for assigning a unique number to each value in a certain finite set and translating (both ways) between values and their numbers.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-GraphNumbering" class="anchored"><a href="#module-GraphNumbering" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="GraphNumbering/index.html">GraphNumbering</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>GraphNumbering</code> offers a facility for discovering and numbering the reachable vertices in a finite directed graph.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Indexing" class="anchored"><a href="#module-Indexing" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Indexing/index.html">Indexing</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This module provides support for constructing finite sets at the type level and for encoding the inhabitants of these sets as runtime integers. These runtime integers are statically branded with the name of the set that they inhabit, so two inhabitants of two distinct sets cannot be inadvertently confused.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Tabulate" class="anchored"><a href="#module-Tabulate" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Tabulate/index.html">Tabulate</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Tabulate</code> offers facilities for tabulating a function, that is, eagerly evaluating this function at every point in its domain, so as to obtain an equivalent function that can be queried in constant time.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Gensym" class="anchored"><a href="#module-Gensym" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Gensym/index.html">Gensym</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Gensym</code> offers a simple facility for generating fresh integer identifiers.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-HashCons" class="anchored"><a href="#module-HashCons" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="HashCons/index.html">HashCons</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>HashCons</code> offers support for setting up a hash-consed data type, that is, a data type whose values carry unique integer identifiers.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-DataFlow" class="anchored"><a href="#module-DataFlow" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="DataFlow/index.html">DataFlow</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>DataFlow</code> performs a forward data flow analysis over a directed graph.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-CompactQueue" class="anchored"><a href="#module-CompactQueue" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="CompactQueue/index.html">CompactQueue</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This module implements a mutable FIFO queue, like OCaml's <code>Queue</code> module. In comparison with <code>Queue</code>, it uses a more compact internal representation: elements are stored contiguously in an array. This has a positive impact on performance: both time and memory consumption are reduced.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Prop" class="anchored"><a href="#module-Prop" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Prop/index.html">Prop</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Prop</code> offers a number of ready-made implementations of the signature <code>PROPERTY</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Fix" class="anchored"><a href="#module-Fix" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Fix/index.html">Fix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Fix</code> offers support for computing the least solution of a set of monotone equations, as described in the unpublished paper &quot;Lazy Least Fixed Points in ML&quot;. In other words, it allows defining a recursive function of type <code>variable -&gt; property</code>, where cyclic dependencies between variables are allowed, and properties must be equipped with a partial order. The function thus obtained performs the fixed point computation on demand, in an incremental manner, and is memoizing.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Make" class="anchored"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Make/index.html">Make</a></span><span> (<a href="Make/argument-1-M/index.html">M</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) (<a href="Make/argument-2-P/index.html">P</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>