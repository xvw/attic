<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Preface (preface.Preface)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">preface</a> &#x00BB; Preface</nav><header class="odoc-preamble"><h1>Module <code><span>Preface</span></code></h1><p>The library is divided into 3 parts (in the user area) which serve complementary purposes.</p></header><nav class="odoc-toc"><ul><li><a href="#abstraction-implementations">Abstraction implementations</a><ul><li><a href="#specifications">Specifications</a></li><li><a href="#achievements">Achievements</a></li><li><a href="#concepts,-naming-and-terminology">Concepts, Naming and Terminology</a></li></ul></li><li><a href="#standard-library">Standard library</a><ul><li><a href="#common-datatypes">Common datatypes</a></li><li><a href="#collection">Collection</a></li><li><a href="#error-handling">Error handling</a></li><li><a href="#functions">Functions</a></li><li><a href="#transformers-over-identity">Transformers over identity</a></li><li><a href="#static-analysis">Static Analysis</a></li></ul></li></ul></nav><div class="odoc-content">
<table border="0" cellspacing="0" style="width: 100%;">
  <tr>
    <td style="border:1px solid #d5d5d5; padding: 6px;">
      <strong style="font-weight: 900;">Preface.Specs</strong>
    </td>
    <td style="border:1px solid #d5d5d5; padding: 6px;">
      Contains all the interfaces of the available abstractions. 
      The specifications resemble the <code>_intf</code> suffixed 
      signatures found in other libraries in the OCaml ecosystem.
    </td>
  </tr>
  <tr>
    <td style="border:1px solid #d5d5d5; padding: 6px;">
      <strong style="font-weight: 900;">Preface.Make</strong>
    </td>
    <td style="border:1px solid #d5d5d5; padding: 6px;">
      Contains the set of <i>functors</i> (in the ML sense of the term) 
      for concretising abstractions. Schematically, a module in 
      <code>Preface.Make</code> takes a module (or modules) respecting a 
      signature described in <code>Preface.Specs</code> to produce a 
      complete signature (also described in <code>Preface.Specs</code>).
    </td>
  </tr>
  <tr>
    <td style="border:1px solid #d5d5d5; padding: 6px;">
      <strong style="font-weight: 900;">Preface</strong>
    </td>
    <td style="border:1px solid #d5d5d5; padding: 6px;">
      Contains concrete implementations, constructs that implement 
      abstractions described in <code>Preface.Specs</code> by means of 
      the functors present in <code>Preface.Make</code>. 
      This library is, at least, an example of the use of 
      <code>Specs</code> and <code>Make</code>.
    </td>
  </tr>
</table>
<h2 id="abstraction-implementations"><a href="#abstraction-implementations" class="anchor"></a>Abstraction implementations</h2><p>Functor (in Haskell sense), Applicatives and monads are some of the best known abstractions in functional programming. Indeed, they allow recurrent problems to be solved in an elegant way. Generally, thanks to certain mechanisms linked to the languages that implement them (in Haskell, for example, using typeclasses), it is possible, by defining only a small subset of their combinators, to derive many others. So the purpose of &quot;this part of the library&quot; is to provide mechanisms for deriving combinators for a given type and a chosen abstraction, respecting OCaml programming idioms as much as possible.</p><h3 id="specifications"><a href="#specifications" class="anchor"></a>Specifications</h3><p>This module describes the specifications of the abstractions provided by <code>Preface</code>. These specifications, which correspond to interfaces (<code>module types</code> in OCaml terminology) serve as constraints for the <code>functors</code> described in <code>Preface.Make</code> and centralise the documentation. Using a separate module allows cyclic dependencies to be resolved if one module can be described by another module and <em>vice versa</em>.</p><div class="odoc-spec"><div class="spec module" id="module-Specs" class="anchored"><a href="#module-Specs" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Specs</span><span> = <a href="../Preface_specs/index.html">Preface_specs</a></span></code></div></div><h3 id="achievements"><a href="#achievements" class="anchor"></a>Achievements</h3><p>In order to produce embodiments for the abstractions described in <code>Preface.Specs</code>, <code>Preface.Make</code> offers a collection of functors that take modules constrained by the interfaces described in <code>Preface.Specs</code> to produce modules that respect the more complete interfaces also described in <code>Preface.Specs</code>.</p><div class="odoc-spec"><div class="spec module" id="module-Make" class="anchored"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Make</span><span> = <a href="../Preface_make/index.html">Preface_make</a></span></code></div></div><h3 id="concepts,-naming-and-terminology"><a href="#concepts,-naming-and-terminology" class="anchor"></a>Concepts, Naming and Terminology</h3><p>The modular design of Preface may seem a little intimidating at first glance. Let's look at the logic of the cut to understand how best to use it to describe new achievements of abstractions.</p><p>Abstractions must respect a minimum interface, however, sometimes there are several paths to describe the abstraction. For example, building a <code>Monad</code> on a type requires a <code>return</code> (or <code>pure</code> depending on the convention in practice) and:</p><ul><li><code>bind</code>/<code>&gt;&gt;=</code></li><li>or <code>map</code> and <code>join</code></li><li>or sometimes <code>&gt;=&gt;</code></li></ul><p>In addition, on the basis of these minimum combinators, it is possible to derive other combinators. However, it happens that these combinators are not implemented in an optimal way (this is the cost of abstraction). In the OCaml ecosystem, the use of polymorphic variants is sometimes used to give the user the freedom to implement, or not, a function by wrapping the function definition in a value of this type:</p><pre><code>val f : [&lt; `Derived | `Custom of 'a -&gt; 'b ] </code></pre><p>Instead of relying on this kind of (rather clever!) trick, we decided to rely mainly on the module language.</p><p>To make it easy to describe the embodiment of an abstraction, but still allow for the possibility of providing more efficient implementations (that propagate new implementations on aliases, such as infix operators, or functions that use these functions), Preface proposes a rather particular cut.</p><p>Each abstraction is broken down into several sub-modules:</p>
<table border="0" cellspacing="0" style="width: 100%;">
  <tr>
    <td style="border:1px solid #d5d5d5; padding: 6px;">
      <strong style="font-weight: 900;"><code>Core</code></strong>
    </td>
    <td style="border:1px solid #d5d5d5; padding: 6px;">
        This module describes all the fundamental operations. For example, 
       for a monad, we would find <code>return<code>, <code>map</code>, 
       <code>bind</code>, <code>join</code> and 
       <code>compose_left_to_right</code>
    </td>
  </tr>
  <tr>
    <td style="border:1px solid #d5d5d5; padding: 6px;">
      <strong style="font-weight: 900;"><code>Operation</code></strong>
    </td>
    <td style="border:1px solid #d5d5d5; padding: 6px;">
        The module contains the set of operations that can be described 
        using the <code>Core</code> functions.
    </td>
  </tr>
  <tr>
    <td style="border:1px solid #d5d5d5; padding: 6px;">
      <strong style="font-weight: 900;"><code>Infix</code></strong>
    </td>
    <td style="border:1px solid #d5d5d5; padding: 6px;">
        The module contains infix operators built on top of the 
        <code>Core</code> and <code>Operation</code>.
    </td>
  </tr>
  <tr>
    <td style="border:1px solid #d5d5d5; padding: 6px;">
      <strong style="font-weight: 900;"><code>Syntax</code></strong>
    </td>
    <td style="border:1px solid #d5d5d5; padding: 6px;">
        The module contains the <code>let</code> operators (such as 
        <code>let*</code> and <code>let+</code> for example), built with 
        the <code>Core</code> and <code>Operation</code> functions.
    </td>
  </tr>
</table>
<p><em>Sometimes it happens that some modules are not present (e.g. when there are no infix operators) or sometimes some additional modules are added, but in general the documentation is clear enough.</em></p><p>The functors exposed in <code>Preface.Make</code> allow you to build each component one by one (<code>Core</code>, <code>Operation</code>, using <code>Core</code>, and <code>Infix</code> and <code>Syntax</code> using <code>Core</code> and <code>Operation</code>) and then group all these modules together to form the abstraction. Or use the <em>Happy Path</em>, which generally offers a similar approach to functors which builds <code>Core</code> but builds the whole abstraction.</p>  
      <center>
        <img
          style="width:75%; margin: 8%;"
          src="https://ocaml-preface.github.io/images/cut.svg"
          alt="Module cutting"
        >
      </center> <p>Although it is likely that the use of the <em>Happy Path</em> covers a very large part of the use cases and that it is not necessary to achieve every abstraction by hand, it is still possible to do so.</p><p>In addition, it is sometimes possible to describe one abstraction by specialising another. In general, these specialisations follow this naming convention: <code>From_name (More_general_module)</code> or <code>To_name (Less_general_module)</code> and sometimes you can build a module on top of another, for example Selective on top of Applicative and the naming follows this convention: <code>Over_name (Req)</code>, ie: <code>Selective.Over_applicative</code>.</p><h2 id="standard-library"><a href="#standard-library" class="anchor"></a>Standard library</h2><p>Whereas the previous section dealt mainly with the achievements of abstractions (using functor machinery). This section documents the standard Preface library. A collection of already implemented abstractions for relatively common data structures.</p><div class="odoc-include"><h4 id="common-datatypes"><a href="#common-datatypes" class="anchor"></a>Common datatypes</h4><div class="odoc-spec"><div class="spec module" id="module-Void" class="anchored"><a href="#module-Void" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Void</span><span> = <a href="../Preface_stdlib/Void/index.html">Preface_stdlib.Void</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Identity" class="anchored"><a href="#module-Identity" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Identity</span><span> = <a href="../Preface_stdlib/Identity/index.html">Preface_stdlib.Identity</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Option" class="anchored"><a href="#module-Option" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Option</span><span> = <a href="../Preface_stdlib/Option/index.html">Preface_stdlib.Option</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Either" class="anchored"><a href="#module-Either" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Either</span><span> = <a href="../Preface_stdlib/Either/index.html">Preface_stdlib.Either</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Pair" class="anchored"><a href="#module-Pair" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Pair</span><span> = <a href="../Preface_stdlib/Pair/index.html">Preface_stdlib.Pair</a></span></code></div></div><h4 id="collection"><a href="#collection" class="anchor"></a>Collection</h4><div class="odoc-spec"><div class="spec module" id="module-List" class="anchored"><a href="#module-List" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>List</span><span> = <a href="../Preface_stdlib/List/index.html">Preface_stdlib.List</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Nonempty_list" class="anchored"><a href="#module-Nonempty_list" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Nonempty_list</span><span> = <a href="../Preface_stdlib/Nonempty_list/index.html">Preface_stdlib.Nonempty_list</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Seq" class="anchored"><a href="#module-Seq" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Seq</span><span> = <a href="../Preface_stdlib/Seq/index.html">Preface_stdlib.Seq</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Stream" class="anchored"><a href="#module-Stream" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Stream</span><span> = <a href="../Preface_stdlib/Stream/index.html">Preface_stdlib.Stream</a></span></code></div></div><h4 id="error-handling"><a href="#error-handling" class="anchor"></a>Error handling</h4><div class="odoc-spec"><div class="spec module" id="module-Exn" class="anchored"><a href="#module-Exn" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Exn</span><span> = <a href="../Preface_stdlib/Exn/index.html">Preface_stdlib.Exn</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Result" class="anchored"><a href="#module-Result" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Result</span><span> = <a href="../Preface_stdlib/Result/index.html">Preface_stdlib.Result</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Validation" class="anchored"><a href="#module-Validation" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Validation</span><span> = <a href="../Preface_stdlib/Validation/index.html">Preface_stdlib.Validation</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Try" class="anchored"><a href="#module-Try" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Try</span><span> = <a href="../Preface_stdlib/Try/index.html">Preface_stdlib.Try</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Validate" class="anchored"><a href="#module-Validate" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Validate</span><span> = <a href="../Preface_stdlib/Validate/index.html">Preface_stdlib.Validate</a></span></code></div></div><h4 id="functions"><a href="#functions" class="anchor"></a>Functions</h4><div class="odoc-spec"><div class="spec module" id="module-Fun" class="anchored"><a href="#module-Fun" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Fun</span><span> = <a href="../Preface_stdlib/Fun/index.html">Preface_stdlib.Fun</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Predicate" class="anchored"><a href="#module-Predicate" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Predicate</span><span> = <a href="../Preface_stdlib/Predicate/index.html">Preface_stdlib.Predicate</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Continuation" class="anchored"><a href="#module-Continuation" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Continuation</span><span> = <a href="../Preface_stdlib/Continuation/index.html">Preface_stdlib.Continuation</a></span></code></div></div><h4 id="transformers-over-identity"><a href="#transformers-over-identity" class="anchor"></a>Transformers over identity</h4><p>There are some (monad or comonad) transformers defined in <code>Spec/Make</code>. In <code>Stdlib</code> these are some concretised version using <code>Identity</code> as inner monad or comonad.</p><div class="odoc-spec"><div class="spec module" id="module-Reader" class="anchored"><a href="#module-Reader" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Reader</span><span> = <a href="../Preface_stdlib/Reader/index.html">Preface_stdlib.Reader</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Writer" class="anchored"><a href="#module-Writer" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Writer</span><span> = <a href="../Preface_stdlib/Writer/index.html">Preface_stdlib.Writer</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-State" class="anchored"><a href="#module-State" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>State</span><span> = <a href="../Preface_stdlib/State/index.html">Preface_stdlib.State</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Store" class="anchored"><a href="#module-Store" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Store</span><span> = <a href="../Preface_stdlib/Store/index.html">Preface_stdlib.Store</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Env" class="anchored"><a href="#module-Env" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Env</span><span> = <a href="../Preface_stdlib/Env/index.html">Preface_stdlib.Env</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Traced" class="anchored"><a href="#module-Traced" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Traced</span><span> = <a href="../Preface_stdlib/Traced/index.html">Preface_stdlib.Traced</a></span></code></div></div><h4 id="static-analysis"><a href="#static-analysis" class="anchor"></a>Static Analysis</h4><p><code>Applicatives</code>, <code>Selectives</code>, <code>Profunctors</code> and <code>Arrows</code> allow, contrary to monads, to perform static analyses on calculation workflows. <code>Over</code> and <code>Under</code> allow optimistic or pessimistic approximations.</p><div class="odoc-spec"><div class="spec module" id="module-Approximation" class="anchored"><a href="#module-Approximation" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Approximation</span><span> = <a href="../Preface_stdlib/Approximation/index.html">Preface_stdlib.Approximation</a></span></code></div></div></div></div></body></html>